#+TITLE: Metabolomics data pre-processing
#+AUTHOR: Johannes Rainer
#+EMAIL: johannes.rainer@eurac.edu
#+OPTIONS: ^:{} toc:nil
#+PROPERTY: header-args:R :exports code
#+PROPERTY: header-args:R :results silent
#+PROPERTY: header-args:R :session *Rmetabo*
#+STARTUP: overview

#+BEGIN_EXPORT html
---
title: "Metabolomics data pre-processing"
author: "Johannes Rainer"
graphics: yes
date: "`r doc_date()`"
output:
  BiocStyle::html_document2:
    number_sections: true
    toc_depth: 2
bibliography: metabolomics-references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

#+END_EXPORT


* Metabolomics data pre-processing

** Setup

This workflow requires R version >= 3.4 and the following packages:

+ =xcms=: for pre-processing of metabolomics data. A package version >= 2.99.0 is
  required. The package depends on =mzR= for data import and uses classes from the
  =MSnbase= package.
+ =faahKO=: provides the data set processed here.
+ =RColorBrewer=: for color definitions.
+ =doParallel=: to set-up parallel processing. =xcms= uses parallel processing with
  the =BiocParallel= package in most algorithms. While =BiocParallel='s default
  parallel processing setup (i.e. using =multicore= on Unix systems and =snow= for
  Windows) works on most systems this seems to be problematic/erratic on recent
  macOS versions. Pre-registering and setting up the parallel processing first
  using the =doParallel= package and using this in =BiocParallel= seems to avoid
  such problems.

#+NAME: libraries
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Style
  library(BiocStyle)
  ## Data processing
  library(xcms)
  ## Toy data set for data processing
  library(faahKO)
  ## For color definitions
  library(RColorBrewer)
  ## For a working parallel processing setup on Mac systems
  library(doParallel)
#+END_SRC

Parallel processing setup.

#+NAME: parallel-setup
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Set up the parallel processing using doParallel.
  registerDoParallel(4)
  ## Register this setup for BiocParallel and make it default.
  register(DoparParam(), default = TRUE)
#+END_SRC

*Hint* the solutions for the exercises are shown in the
/metabolomics-pre-processing.org/ file, search for /solution/.

** Introduction

This workflow illustrates the use of Bioconductor packages for the
pre-processing of LCMS-based metabolomics data sets. While other package exist
too (such as =yamss= \cite{Myint:2017fp}), this workshop focuses on =xcms=
\cite{Smith:2006ic} and uses the functionality of its new user interface. The
pre-processing aims to identify the features possibly corresponding to
metabolites and to quantify them. The topics covered in this document are:
- Data import, organization and handling.
- Chromatographic peak detection.
- Alignment (retention time correction).
- Correspondence (matching of chromatographic peaks within and between samples).
The result from this metabolomics pre-processing is a table of intensities with
rows corresponding to /features/ (ions with a unique mass-to-charge ratio and
retention time) and columns to samples.

The workflow does not cover (yet) data normalization strategies or
identification of metabolites (i.e. mapping of detected features to
corresponding metabolites). Also, the workflow focuses on gas/liquid
chromatography (G/LC) mass spectrometry (MS) which combines the physical
separation capabilities of the chromatography with the mass analysis
capabilities of the MS. Chromatography is usually preferred in mass spectrometry
experiments with complex samples because the added dimension (the retention time
rt) helps to discriminate between analytes with identical mass-to-charge ratios
(mz).

For more details and description of the general metabolomics data workflow see
\cite{Sugimoto:2012jt}\cite{Smith:2014di}.

** Definitions and naming convention

The aim of the metabolomics data pre-processing is the identification of peaks
in the chromatographic dimension. These peaks are referred to as
/chromatographic peaks/ in this document to distinguish them from /mass/ peaks
identified in proteomics. The term /feature/ refers to individual ions with a
unique mass-to-charge ratio (mz) and a unique retention time (rt). Such features
are defined during the correspondence step in which the detected chromatographic
peaks are matched between (and within) samples.

** Data import, organization and handling

A variety of different, vendor-specific, file formats exist for
proteomics/metabolomics. This data files have to be converted first into one of
the file formats supported by the =mzR= package, i.e. the open /mzML/ or the /netCDF/
file format. For metabolomics experiments it is suggested to load the data using
the =readMSData2= function (from the =MSnbase= package \cite{Gatto:2012io}) into an
=OnDiskMSnExp= object. Such objects hold only general spectra data (number of
spectra in a file, retention time of spectra etc) in memory while the full raw
data is accessed on demand. This keeps the memory footprint and requirements
small and enables thus analyses also of large scale metabolomics experiments
(for more details on the =OnDiskMSnExp= object see please the help pages and
vignettes in the =MSnbase= package). The new user interface of the =xcms= package
used in this document makes extensive use of objects from the =MSnbase= package
and hence reuses all of their functionality. This helps also to define a general
code base for MS-based data analysis.

Below we read the raw data files (in netCDF format) from the =faahKO= data
package. This package provides a subset of the data from
\cite{Saghatelian:2004cx} examining the metabolic consequences of the knock-out
of the fatty acid amide hydrolase (Faah) gene in mice. The data subset comprises
spinal cord samples from 6 knock-out and 6 wild type mice. Each file contains
centroided data from an LC-MS experiment acquired in positive ion mode in a mz
range from 200-600 and retention time range from 2500-4500 seconds.

#+NAME: read-faahKO
#+BEGIN_SRC R :results silent :ravel message = FALSE, results = "hide", warning = FALSE
  ## Get the file names
  cdf_files <- dir(system.file("cdf", package = "faahKO"), recursive = TRUE,
		   full.names = TRUE)

  ## Define the sample grouping.
  s_groups <- rep("KO", length(cdf_files))
  s_groups[grep(cdf_files, pattern = "WT")] <- "WT"
  ## Define a data.frame that can be used as phenodata
  pheno <- data.frame(sample_name = sub(basename(cdf_files), pattern = ".CDF",
					replacement = "", fixed = TRUE),
		      sample_group = s_groups, stringsAsFactors = FALSE)

  ## Read the data.
  faahKO_raw <- readMSData2(cdf_files, pdata = new("NAnnotatedDataFrame", pheno))

#+END_SRC

The data is organized by spectrum, i.e. for each retention time we have a
=Spectrum1= object containing the mz and intensity duplets measured by the
mass spec. Below we extract one of the spectra and evaluate the data it
contains.

#+NAME: single-spectrum
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Access the 3rd spectrum in the data set.
  spctr <- faahKO_raw[[3]]

  ## Get the retention time when the spectrum was measured
  rtime(spctr)

  ## Access the mz of the spectrum
  head(mz(spctr)) 

  ## And the associated intensities
  head(intensity(spctr))

  ## Optionally plot the Spectrum by plotting the mz values on the x- and
  ## the associated intensities on the y-axis.
#+END_SRC

We can use various accessor functions to extract information from the
=OnDiskMSnExp= object, such as =rtime= to get the retention time from each
spectrum. Many of these methods directly access information stored in the
object's =fData= (corresponding to the spectrum headers in the mzML/netCDF files)
and are thus very fast. The =mz=, =intensity= and =spectra= methods on the other hand
require the original data to be read and are thus slower.

It is also important to note that the spectrum data within the object is not
organized by sample and data is always returned as a one-dimensional vector. The
association between a spectrum and the file from which it originates is provided
by the =fromFile= method which returns an integer vector with the index of the
file from which the spectrum was extracted. Various filter methods allow a fast
and simple sub-setting of the full experiment. In the example below we create a
total ion chromatogram (TIC) using the =filterFile= method to subset the object to
data from a certain file. The total ion current per spectrum is extracted with
the =tic= method. The TIC plots the sum of all measured intensities for a given
retention time (i.e. a spectrum) against the retention time.

#+NAME: faahKO-tic
#+BEGIN_SRC R :results silent :ravel message = FALSE, fig.align = 'center', fig.width = 8, fig.height = 4
  ## Define the sample colors
  sample_colors <- brewer.pal(3, "Set1")[1:2]
  names(sample_colors) <- c("KO", "WT")
  ## Subset the full raw data by file and plot the data.
  tmp <- filterFile(faahKO_raw, file = 1)
  plot(x = rtime(tmp), y = tic(tmp), xlab = "retention time", ylab = "TIC",
       col = paste0(sample_colors[pData(tmp)$sample_group], 80), type = "l")
  for (i in 2:length(fileNames(faahKO_raw))) {
      tmp <- filterFile(faahKO_raw, file = i)
      points(rtime(tmp), tic(tmp), type = "l",
	     col = paste0(sample_colors[pData(tmp)$sample_group], 80))
  }
  legend("topleft", col = sample_colors, legend = names(sample_colors), lty = 1)
#+END_SRC

The TIC or the /base peak chromatogram/ (BPC, maximum signal per spectrum against
its retention time) are useful plots to get a first general overview of an
experiment and can also be used for quality control purposes, e.g. to spot
problematic samples. Plotting the distribution of the total ion currents (=tic=)
or the /base peak intensities/ (=bpi=) per file using boxplots can also be used for
quality assessment.

+ *Exercise 1*: use the =tic= and =fromFile= methods to create the TIC.

#+NAME: solution-exercise1
#+BEGIN_SRC R :results silent :ravel echo = FALSE, results = "hide", message = FALSE
  ## The tic returns a vector, one value for each spectrum in the experiment. The
  ## values are not organized by sample/file
  head(tic(faahKO_raw))

  ## The fromFile method returns the index from the file the spectrum derives
  head(fromFile(faahKO_raw))

  ## Extract the total ion current and retention times and split them by file.
  tics <- split(tic(faahKO_raw), f = fromFile(faahKO_raw))
  rts <- split(rtime(faahKO_raw), f = fromFile(faahKO_raw))
  ## Define the color for each sample
  cols <- paste0(sample_colors[pData(faahKO_raw)$sample_group], 80)
  ## initialize plot
  plot(3, 3, pch = NA, xlim = range(rts), ylim = range(tics), main = "TIC",
       xlab = "retention time", ylab = "intensity")
  tmp <- mapply(rts, tics, cols, FUN = function(x, y, col) {
      points(x = x, y = y, col = col, type = "l")
  })
#+END_SRC

In most mzML and netCDF files the MS data is organized by spectrum
(i.e. intensity values by their corresponding mz value) and, as detailed above,
also the =OnDiskMSnExp= object returns data by spectrum. In LC-MS metabolomics,
however, peak detection is performed (for small slices along the mz dimension)
in the time dimension and hence /orthogonally/ to the spectrum data. To extract
intensity data by retention time, =xcms= defines the =extractChromatograms= method
and the =Chromatogram= class. Below we create the base peak chromatogram (BPC,
maximum signal per spectrum against its retention time) which usually could be
generated with =bpi= method in a similar fashion than the TIC above. The present
netCDF files do however not provide the base peak intensities in the spectrum
headers within the files and the =bpi= method does thus return =-1= for all
spectra. We have to create the BPC therefore using the =extractChromatogram=
method that loads the full spectrum data from all files and aggregates the
intensities per spectrum. The result is returned as a =list= of =Chromatogram=
objects, one for each file. This is relatively fast for the present files (also
because data is read in parallel) but can be slow with larger, higher
resolution, MS experiments.

#+NAME: faahKO-bpc
#+BEGIN_SRC R :results silent :ravel message = FALSE, fig.align = 'center', fig.width = 8, fig.height = 4
  ## Extract chromatograms for the full mz and rt range. By specifying
  ## aggregationFun = "max" we extract the maximum intensity per spectrum and
  ## get hence base peak chromatograms
  chrs <- extractChromatograms(faahKO_raw, aggregationFun = "max")

  ## Plot the chromatograms
  plotChromatogram(
      chrs,
      col = paste0(sample_colors[pData(faahKO_raw)$sample_group], 80))
  legend("topleft", col = sample_colors, legend = names(sample_colors), lty = 1)
#+END_SRC

The BPC are similar between individual samples, but seem to be shifted in the
retention time dimension. This shift will be corrected in the
alignment/retention time adjustment step.

Next we visualize the chromatogram for specific ions, i.e. for a small mz range
and/or retention time window to inspect what type of chromatographic peaks have
to be identified in the present LC-MS experiment.

#+NAME: faahKO-chromatogram-example
#+BEGIN_SRC R :results silent :ravel message = FALSE, warning = FALSE, fig.align = "center", fig.width = 8, fig.height = 8, fig.cap = "Chromatographic peak example. Extracted ion chromatogram for mz = 335 and a retention time from 2700 to 2900 seconds. Each line representing the signal measured in one sample."
  ## Extract the chromatogram for one mz value and a given rt range
  chrs <- extractChromatograms(faahKO_raw, mz = 335, rt = c(2700, 2900))

  plotChromatogram(chrs,
                   col = paste0(sample_colors[pData(faahKO_raw)$sample_group], 80))

#+END_SRC

The chromatographic peaks are about 40-50 seconds wide in this experiment. Note
that not in all spectra (for all retention times) a signal was measured for the
given mz range. The lines are thus not continuous in the plot above.

For the maximal intensity measured of the chromatographic peak we can also
extract the corresponding spectrum in a file. Below we extract such spectrum for
the first file and plot it.

#+NAME: faahKO-spectrum-example
#+BEGIN_SRC R :results silent :ravel message = FALSE, warning = FALSE, fig.align = "center", fig.width = 8, fig.height = 8, fig.cap = "Spectrum for rt of 2780 seconds. Spectrum for the retention time associated with the highest signal of the chromatographic peak in the first file. The triangle indicates the mz corresponding to the chromatographic peak shown above."
  ## Subsetting the original object to the given retention time range and file,
  ## this returns an OnDiskMSnExp referencing to a single spectrum.
  subs <- filterFile(filterRt(faahKO_raw, rt = c(2779, 2781)), file = 1)

  ## Extract the Spectrum
  spctr <- spectra(subs)[[1]]

  plot(mz(spctr), intensity(spctr), type = "h", xlab = "mz", ylab = "intensity")
  points(x = 335, y = -10000, pch = 2)

#+END_SRC

Apparently there are many mass peaks present at the specific retention time,
most of them larger than the one for the chromatographic peak from the example
above.

As we can see in the spectrum above, for the retention time corresponding to the
maximal intensity of the chromatographic peak shown above multiple (mass) peaks
are measured.

** Chromatographic peak detection

The first task in the pre-processing of LC-MS metabolomics data is the detection
of peaks in the retention time dimension (i.e. chromatographic peaks) for MS
data slices along the mz dimension. The most commonly used algorithm is /centWave/
\cite{Tautenhahn:2008fx} that performs a relatively robust peak detection. Peak
detection can be performed on =OnDiskMSnExp= objects using the =findChromPeaks=
method providing in addition a algorithm-specific parameter class, such as an
=CentWaveParam= for centWave based peak detection, or =MatchedFilterParam= for peak
detection using the /matched filter/ algorithm \cite{Smith:2006ic}.

Below we use the default parameters for the peak detection (which is however
never a good idea in LC-MS data pre-processing). The peak detection is performed
in parallel for each file.

#+NAME: faahKO-centWave-default
#+BEGIN_SRC R :results silent :ravel message = FALSE, warning = FALSE
  ## Create the parameter object for centWave
  cwp <- CentWaveParam(noise = 200)
  faahKO <- findChromPeaks(faahKO_raw, param = cwp)
  faahKO
#+END_SRC

The result from the peak detection is an =XCMSnExp= object, which is an extension
to the =OnDiskMSnExp= object. While being a container for metabolomics
pre-processing results, this object inherits the =OnDiskMSnExp='s ability to
access the raw data files. Below we access the results from this analysis step
using the =chromPeaks= method.

#+NAME: faahKO-chromPeaks
#+BEGIN_SRC R :results silent :ravel message = FALSE
  head(chromPeaks(faahKO))
#+END_SRC

Each line in the =matrix= represents a chromatographic peak identified in one
sample. The index of the file in which the peak was detected is given in column
="sample"= while the definition of the peak is provided in columns ="mzmin"= ,
="mzmax"= , ="rtmin"= and ="rtmax"= and the peaks intensities in columns ="into"=
(integrated peak signal) and ="maxo"= (maximum signal at the peak's apex).

The =XCMSnExp= object keeps also track of all performed processing steps storing
also the employed parameter classes and guaranteeing hence full
reproducibility. This information can be accessed with the =processHistory= method
that returns a =list= of processing steps. Below we use this method to extract the
parameter class used for the chromatographic peak detection.

#+NAME: faahKO-processHistory
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Getting the first process history step, in our case the chromatographic
  ## peak detection.
  ph <- processHistory(faahKO)[[1]]

  ph

  ## Extracting the Parameter class employed
  processParam(ph)
#+END_SRC

Whether peak detection was successful is hard to tell. The numbers of detected
peaks can provide some first information (is the number much lower than
expected? are there files with considerably fewer peaks?). Also summaries of the
rt and mz widths of identified peaks might be informative. Plotting the raw data
and visually inspecting the detected peaks represents however one of the best
options to estimate peak detection performance. This is in most cases done on a
handful of known compounds or internal control compounds added to each sample.
The new user interface facilitates extraction of full or small slices of the MS
data and enables an easy access to the original (or processed) data at any
stage. Performance is guaranteed by making use of the indexing capabilities
of mzML and netCDF files reading only sub-sets of the data where possible. The
=getEIC= method from the /old/ =xcms= user interface provided similar functionality
but loaded the full data with each call. Also, not the original values were
returned, but intensities from the /profile matrix/ which contains intensities
binned in equidistant slices along the mz dimension.

Below we plot the chromatogram for the mz of 335 and highlight also all
identified chromatographic peaks in that region.

#+NAME: faahKO-chromatogram-example
#+BEGIN_SRC R :results silent :ravel message = FALSE, warning = FALSE, fig.align = "center", fig.width = 8, fig.height = 8, fig.cap = "Chromatographic peak example. Extracted ion chromatogram for mz = 335 and a retention time from 2700 to 2900 seconds. Each line representing the signal measured in one sample. Rectangles indicate the identified chromatographic peaks."
  ## Extract the chromatogram for one mz value and a given rt range
  chrs <- extractChromatograms(faahKO, mz = 335, rt = c(2700, 2900))

  plotChromatogram(chrs,
		   col = paste0(sample_colors[pData(faahKO)$sample_group], 80))
  highlightChromPeaks(
      faahKO, rt = c(2700, 2900), mz = 335,
      border = paste0(sample_colors[pData(faahKO)$sample_group], 40))
#+END_SRC

Over and above the peak detection seemed to be OK although in some samples no
peaks were identified, mostly due to low (and sparse) signal intensities.

The =chromPeaks= method allows also to retrieve peaks for a specific =mz= or =rt=
range. This allows to evaluate whether and how many chromatographic peaks have
been detected for a certain mz-rt region. Below we extract all peaks identified
in the above mz-rt region.

#+NAME: faahKO-chromPeaks-example
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Extract detected peaks for a mz-rt region. The parameter ppm allows to
  ## extend the mz range slightly
  chromPeaks(faahKO, mz = 335, rt = c(2700, 2900), ppm = 10)
#+END_SRC

As we have already seen above, a peak was detected in most samples.

To emphasize the need to adapt the peak detection algorithm setting to each
setup/experiment we load an mzML file from a completely different experimental
setup and perform a centWave peak detection using default settings.

#+NAME: otherdata-peakDetection
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Load one file from a different setup.
  fl <- paste0("./data/","250516_POOL_N_POS_28.mzML.gz")
  raw_data <- readMSData2(fl)

  ## Run peak detection using default CentWave.
  proc_data <- findChromPeaks(raw_data, param = CentWaveParam())

  proc_data

#+END_SRC

The number of detected peaks is very low, much lower than expected.

From the setup it is known that some compounds should be present/detected in the
sample. One of these is /glycine/ with an expected mz of =76.03969968=. Allowing a
ppm of 20 we extract all identified peaks at about the expected mz.

#+NAME: otherdata-glycine-pks
#+BEGIN_SRC R :results silent :ravel message = FALSE
  mz_glyc <- 76.03969968

  ## Extract chromatographic peaks matching the mz of glycine, allowing
  ## a 20ppm deviation.
  pks <- chromPeaks(proc_data, mz = mz_glyc, ppm = 20)
  pks
#+END_SRC

Not a single peak was detected in the expected region. Next we extract and plot
the corresponding ion chromatogram to evaluate what signal is present in the
region.

#+NAME: otherdata-glycine-eic
#+BEGIN_SRC R :results silent :ravel message = FALSE, fig.align = "center", fig.width = 8, fig.height = 8, fig.cap = "Extracted ion chromatogram for glycine."
  ## Extend the mz range by 10 ppm on both sides.
  mzr <- c(mz_glyc - mz_glyc * 10 / 1e6, mz_glyc + mz_glyc * 10 / 1e6)

  ## Extract the ion chromatogram for glycine
  eic_glyc <- extractChromatograms(proc_data, mz = mzr, rt = c(165, 180))

  ## Plot the chromatogram
  plotChromatogram(eic_glyc, rt = c(165, 180))
#+END_SRC

There is signal at the expected mz/rt, but why was this peak not detected?

+ *Exercise 2*: inspecting the chromatographic peak for glycine, how could you
  improve the centWave peak detection settings? Run peak detection with the
  modified settings and evaluate the results.

#+NAME: solution-exercise-2
#+BEGIN_SRC R :results silent :ravel echo = FALSE, message = FALSE, eval = FALSE
  ## The rt width of the peak is much smaller than the default 20-50 seconds.

  ## Adapt the peakwidth parameter and re-run the peak detection
  cwp <- CentWaveParam(peakwidth = c(2, 10))
  proc_data <- findChromPeaks(raw_data, param = cwp)

  ## Numer of detected peaks:
  nrow(chromPeaks(proc_data))

  ## Average rt width
  mean(chromPeaks(proc_data)[, "rtmax"] - chromPeaks(proc_data)[, "rtmin"])

  ## Do we find a glycine peak?
  chromPeaks(proc_data, mz = mz_glyc, ppm = 20)

  ## Yes we do, and at the expected rt.

  ## plot the data and highlight the peak.
  plotChromatogram(eic_glyc)
  highlightChromPeaks(proc_data, mz = mz_glyc, rt = c(165, 180), ppm = 20)

  ## Peak is eventually even a little too broad.
#+END_SRC

The =IPO= Bioconductor package \cite{Libiseller:2015km} provides functionality for
an automatic tuning of =xcms= peak detection parameters and is thus a good starting point
to automatically tune parameters for a specific metabolomics setup/experiment. Visual
inspection of identified peaks is however crucial to guarantee proper peak
detection.

** Alignment

The time at which analytes elute in the chromatography can vary between samples
(and even compounds). Such a difference was already observable in the example
extracted ion chromatogram plot in the previous section. The alignment step,
also referred to as retention time correction, aims at shifting signals along
the retention time axis to reduce this difference and align the signals between
different samples within an experiment.

A plethora of alignment algorithms exist (see \cite{Smith:2013gr}), with some of
them being implemented also in =xcms=. The method to perform the
alignment/retention time correction in =xcms= is =adjustRtime= which uses different
alignment algorithms depending on the provided parameter class. In the example
below we use the /obiwarp/ method \cite{Prince:2006jj} to align the samples. We
use a =binSize = 0.6= which creates warping functions in mz bins of 0.6. Also here
it is advisable to modify the settings for each experiment and evaluate if
retention time correction did align internal controls or known compounds
properly.

#+NAME: faahKO-obiwarp
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Define the parameters to the obiwarp method
  owp <- ObiwarpParam(binSize = 0.6)

  faahKO <- adjustRtime(faahKO, param = owp)
#+END_SRC

The result from the =adjustRtime= call is the same =XCMSnExp= object containing in
addition the adjusted retention times. The =hasAdjustedRtime= method can be used
to evaluate if the object contains adjusted retention times which can then be
extracted using the =adjustedRtime= method. If an =XCMSnExp= object contains
alignment results, the =rtime= method does also by default return the adjusted
retention times. Raw retention times can then be extracted by passing =adjusted =
FALSE= to the =rtime= method. Note also that by passing the argument =bySample =
TRUE=, the =rtime= and =adjustedRtime= methods allow to extract retention time
grouped by samples.

Below we simply test these methods to get a feeling of the type of result
objects are returned.

#+NAME: faahKO-obiwarp-res
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Do we have adjusted retention times?
  hasAdjustedRtime(faahKO)

  ## Get adjusted retention times for the first 6 spectra
  head(rtime(faahKO))

  ## And the raw retention times
  head(rtime(faahKO, adjusted = FALSE))

  ## By default the methods return again values per spectra. We can however pass
  ## bySample = TRUE and the result is returned as a list of numeric vectors,
  ## each list element representing the retention times for all spectra from one
  ## file
  length(rtime(faahKO, bySample = TRUE))
#+END_SRC

To evaluate the impact of the alignment we plot a base peak chromatogram before
and after retention time correction as well as the deviation between raw and
adjusted retention times.

#+NAME: faahKO-obiwarp-BPCs
#+BEGIN_SRC R :results silent :ravel message = FALSE, fig.align = "center", fig.width = 8, fig.height = 10, fig.cap = "Alignment results. Base peak chromatogram before and after retention time adjustment and difference between raw and adjusted retention times per file."
  ## Extract BPC for each file; this reads all data from the original files.
  chrs <- extractChromatograms(faahKO, aggregationFun = "max")

  ## To plot the BPC with the raw retention times we have to extract the
  ## intensities from the Chromatogram objects and extract the raw rt from
  ## the XCMSnExp with rtime(faahKO, adjusted = FALSE)
  ## Note that using bySample = TRUE the method returns the retention times split
  ## by sample.
  rt_raw <- rtime(faahKO, adjusted = FALSE, bySample = TRUE)
  ## Extract the (base peak) intensities of the chromatograms
  ints <- lapply(chrs, intensity)

  ## Preparing the plot
  par(mfrow = c(3, 1), mar = c(0.5, 4, 1, 0.5))
  ## Plot first the base peak chromatogram with the raw retention times.
  plot(3, 3, pch = NA, xlab = "", ylab = "base peak intensity", xaxt = "n",
       main = "before adjustment", xlim = range(rt_raw), ylim = range(ints))
  cols <- paste0(sample_colors[pData(faahKO)$sample_group], 80)
  tmp <- mapply(rt_raw, ints, cols, FUN = function(x, y, col) {
      points(x, y, col = col, type = "l")
  })

  ## Plot the base peak chromatograms with the adjusted retention times.
  plotChromatogram(chrs, main = "after adjustment", col = cols, xaxt = "n")

  ## Plot the difference between adjusted and raw adjustment.
  par(mar = c(4, 4, 0.5, 0.5))
  plotAdjustedRtime(faahKO, col = cols)
#+END_SRC

The retention time adjustment did align most of the base peaks across
samples. Between 3600 and 3800 seconds the alignment was however less optimal
showing also the strongest retention time adjustment.

It is also important to note that the alignment step adjusts also the reported
retention times for the detected chromatographic peaks. If we were not happy
with the results from the alignment step we could also /drop/ these results using
the =dropAdjustedRtime= method in which case the raw retention times are restored
(also for the detected chromatographic peaks).

+ *Exercise 3*: plot the chromatographic peak for =mz = 335= and =rt = c(2700, 2900)=
  before and after retention time correction. Hint: for the peaks before
  alignment, extract the chromatograms either from the raw =faahKO_raw= object or
  use the =dropAdjustedRtime= method to restore raw retention times.

#+NAME: solution-exercise3
#+BEGIN_SRC R :results silent :ravel echo = FALSE, results = "hide", message = FALSE
  ## To extract the chromatogram before retention time adjustment we have to
  ## drop the retention time adjustment results:
  chrs_raw <- extractChromatograms(dropAdjustedRtime(faahKO),
                                   rt = c(2700, 2900), mz = 335)

  ## Define the color for each sample
  cols <- paste0(sample_colors[pData(faahKO)$sample_group], 80)
  par(mfrow = c(2, 1))
  plotChromatogram(chrs_raw, col = cols)

  ## Extract the chromatograms after adjustment.
  chrs_adj <- extractChromatograms(faahKO, rt = c(2700, 2900), mz = 335)
  plotChromatogram(chrs_adj, col = cols)

  ## Alignment is not perfect for this paricular peak.
#+END_SRC

An alternative to the /obiwarp/ method is the /peakGroups/ method that performs the
alignment using so called /hook/ peaks that are present in most samples. The
retention times are then adjusted by aligning these peaks. Such peaks are
usually being identified using the /peak density/ correspondence method by
enforcing the chromatographic peaks to be present in most samples, could however
also be defined manually.

Note that all alignment methods do depend on the assumption that the samples are
similar (obiwarp: have similar chromatograms and /peak groups/: have metabolites
present in all samples that can be used as hook peaks). 

** Correspondence

The final step in the metabolomics pre-processing is the correspondence that
matches detected chromatographic peaks between samples (and depending on the
settings, also within samples if they are adjacent). The method to perform the
correspondence in =xcms= is =groupChromPeaks=. We will use the /peak density/ method
to group chromatographic peaks. The algorithm combines chromatographic peaks
depending on the density of peaks along the retention time axis within small
slices along the mz dimension. To illustrate this we plot below the chromatogram
for an mz slice with multiple chromatographic peaks within each sample.

#+NAME: faahKO-density-example
#+BEGIN_SRC R :results silent :ravel message = FALSE, fig.align = "center", fig.width = 8, fig.height = 8, fig.cap = "Example for peak density correspondence. Upper panel: chromatogram for an mz slice with multiple peaks. Lower panel: detected peaks at their retention time (x-axis) and index within samples of the experiments (y-axis). The black line represents the peak density estimate. Grouping of peaks based on this density and the provided settings is indicated by grey rectangles."
  ## Define the mz slice.
  mzr <- c(305.05, 305.15)

  ## Extract and plot the chromatograms
  chrs <- extractChromatograms(faahKO, mz = mzr)
  par(mfrow = c(2, 1), mar = c(1, 4, 1, 0.5))
  cols <- sample_colors[pData(faahKO)$sample_group]
  plotChromatogram(chrs, col = paste0(cols, 80), xaxt = "n", xlab = "")
  ## Highlight the detected peaks in that region.
  highlightChromPeaks(faahKO, mz = mzr, col = paste0(cols, "05"),
                      border = paste0(cols, 20))
  ## Define the parameters for the peak density method
  pdp <- PeakDensityParam(bw = 30)
  par(mar = c(4, 4, 1, 0.5))
  plotChromPeakDensity(faahKO, mz = mzr, col = paste0(cols, "60"), param = pdp,
                       pch = 16)

#+END_SRC

The upper panel in the plot above shows the extracted ion chromatogram for each
sample with the detected peaks highlighted. The lower plot plots the retention
time for each detected peak within the different samples. The black solid line
represents the density distribution of detected peaks along the retention
times. Peaks combined into /features/ (peak groups) are indicated with grey
rectangles. This grouping depends on the parameters for the density function and
other parameters passed to the algorithm with the =PeakDensityParam=.

With the default settings (=bw = 30=) the two neighboring/overlapping peaks are
combined into a single feature.

+ *Exercise 4*: change the bandwith of the density function (parameter =bw=) to
  separate the two peaks.

#+NAME: solution-exercise4
#+BEGIN_SRC R :results silent :ravel echo = FALSE, results = "hide", message = FALSE
  par(mfrow = c(4, 1), mar = c(1, 4, 1, 0.5))
  plotChromatogram(chrs, col = paste0(cols, 80), xaxt = "n", xlab = "")
  ## Highlight the detected peaks in that region.
  highlightChromPeaks(faahKO, mz = mzr, col = paste0(cols, "05"),
                      border = paste0(cols, 20))
  ## Small bandwidth
  plotChromPeakDensity(faahKO, mz = mzr, col = paste0(cols, "60"),
                       param = PeakDensityParam(bw = 5), pch = 16)
  ## The smaller peaks are no longer grouped to a feature, because the peak was
  ## identified in too few samples (minFraction parameter of PeakDensityParam)

  ## Next
  plotChromPeakDensity(faahKO, mz = mzr, col = paste0(cols, "60"),
                       param = PeakDensityParam(bw = 25), pch = 16)
  ## Same result; we would need to reduce the minFraction parameter
#+END_SRC

The =bw= is only one of the parameters of the =PeakDensityParam=. Other important
settings are =minFraction=, i.e. the minimal proportion of samples within a group
in which a peak has to be detected for it to be considered a feature and =binSize=
which is the width of the (overlapping) mz slices in which the peak grouping is
performed.

Below we perform the correspondence using the default settings for the
algorithm.

#+NAME: faahKO-correspondence
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Perform the correspondence using default peak density settings
  faahKO <- groupChromPeaks(faahKO, param = PeakDensityParam())
  faahKO
#+END_SRC

The results from the correspondence can be extracted using the
=featureDefinitions= method, that returns a =DataFrame= with the definition of the
features (i.e. the mz and rt ranges and, in column =peakidx=, the index of the
chromatographic peaks in the =chromPeaks= matrix for each feature). The
=featureValues= method returns a =matrix= with rows being features and columns
samples. The content of this matrix can be defined using the =value=
argument. Setting =value = "into"= returns a matrix with the integrated signal of
the peaks corresponding to a feature in a sample. Any column name of the
=chromPeaks= matrix can be passed to the argument =value=. Below we extract the
integrated peak intensity per feature/sample.

#+NAME: faahKO-features
#+BEGIN_SRC R :results silent
  ## Extract the into column for each feature.
  head(featureValues(faahKO, value = "into"))
#+END_SRC

This feature matrix contains =NA= for samples in which no chromatographic peak was
detected in the feature's mz-rt region. While in many cases there might indeed
be no peak signal in the respective region, it might also be that there is
signal, but the peak detection algorithm failed to detect a chromatographic
peak. =xcms= provides the =fillChromPeaks= method to /fill in/ intensity data for such
missing values from the original files. The /filled in/ peaks are added to the
=chromPeaks= matrix and are flagged with an =1= in the ="is_filled"= column. Below we
perform such a filling-in of missing peaks.

#+NAME: faahKO-fillChromPeaks
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Filling missing peaks using default settings. Alternatively we could
  ## pass a FillChromPeaksParam object to the method.
  faahKO <- fillChromPeaks(faahKO)

  head(featureValues(faahKO))
#+END_SRC

For features without detected peaks in a sample, the method extracts all
intensities in the mz-rt region of the feature, integrates the signal and adds a
/filled-in/ peak to the =chromPeaks= matrix. No peak is added if no signal is
measured/available for the mz-rt region of the feature. For these, even after
filling in missing peak data, a =NA= is reported in the =featureValues= matrix.

Below we compare the number of missing values before and after filling in
missing values. We can use the parameter =filled= of the =featureValues= method to
define whether or not filled-in peak values should be returned too.

#+NAME: faahKO-fillChromPeaks-compare
#+BEGIN_SRC R :results silent :ravel message = FALSE
  ## Missing values before filling in peaks
  apply(featureValues(faahKO, filled = FALSE), MARGIN = 2,
	FUN = function(z) sum(is.na(z)))

  ## Missing values after filling in peaks
  apply(featureValues(faahKO), MARGIN = 2,
	FUN = function(z) sum(is.na(z)))
#+END_SRC

+ *Exercise 4*: Compare the intensity of filled-in peaks with those of detected
  peaks.

#+NAME: solution-exercise4
#+BEGIN_SRC R :results silent :ravel echo = FALSE, results = "hide", message = FALSE
  ## Get the intensities of the detected peaks
  not_filled <- featureValues(faahKO, filled = FALSE, value = "into")

  ## Get the intensities of the filled-in peaks:
  ## o Extract all intensities
  filled_in <- featureValues(faahKO, value = "into")
  ## o Set values for detected peaks NA
  filled_in[!is.na(not_filled)] <- NA

  par(mfrow = c(2, 1))
  boxplot(log2(not_filled), main = "Detected peaks",
          ylab = expression(log[2]~intensity))
  boxplot(log2(filled_in), main = "Filled-in peaks",
          ylab = expression(log[2]~intensity))
  ## As expected, the intensities of the filled-in peaks are on average lower,
  ## still, the intensities are considerably high.
#+END_SRC

At last we perform a principal component analysis to evaluate the grouping of
the samples in this experiment. Note that we did not perform any data
normalization hence the grouping might also be influenced by technical biases.

#+NAME: faahKO-PCA
#+BEGIN_SRC R :results silent :ravel message = FALSE, fig.align = "center", fig.width = 8, fig.height = 8, fig.cap = "PCA for the faahKO data set, un-normalized intensities."
  ## Extract the features and log2 transform them
  ft_ints <- log2(featureValues(faahKO, value = "into"))

  ## Perform the PCA.
  pc <- prcomp(t(na.omit(ft_ints)), center = TRUE)

  ## Plot the PCA
  cols <- sample_colors[pData(faahKO)$sample_group]
  pcSummary <- summary(pc)
  plot(pc$x[, 1], pc$x[,2], pch = 21, main = "", 
       xlab = paste0("PC1: ", format(pcSummary$importance[2, 1] * 100, digits = 3),
                     " % variance"),
       ylab = paste0("PC2: ", format(pcSummary$importance[2, 2] * 100, digits = 3),
                     " % variance"), col = "#00000080",
       bg = paste0(cols, 80))
  text(pc$x[, 1], pc$x[,2], labels = pData(faahKO)$sample_name, col = "#00000080",
       pos = 3)
  grid()
#+END_SRC

We can see the expected separation between the KO and WT samples on PC2. On PC1
samples separate based on their ID, samples with an ID <= 18 from samples with
an ID > 18. This separation might be caused by a technical bias
(e.g. measurements performed on different days/weeks) or due to biological
properties of the mice analyzed (sex, age, litter mates etc).

** Topics not covered in this document

+ Normalization: within (per feature signal drift adjustment) batch and between
  batch normalization of intensity values should be performed.
+ Identification of features with different abundances: here we might simply use
  e.g. the =limma= package on the log2 transformed (and normalized) intensities to
  identify features that are different between groups.
+ Identification: annotation of features to metabolites/chemical
  compounds. Bioconductor's =CAMERA= package might be a good starting point.

** References
